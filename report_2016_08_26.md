隔了一天，我报告下情况吧。

## 问题1的解决

#### 原来的想法

昨天我按照了我的想法尝试修复问题1：
- 去掉`onDidChangeContent()`中对一系列表的重置操作。
- 维护一个全局的文件解析字典，以`uri`为`key`，以`Boolean`为`value`，解析过的文件全都记录进去。
- 当`onDidChangeContent()`触发时，必定要重新解析对应`uri`的文件。而在`parse2()`中，在`includekeyword`得到的要解析文件名，在解析之前，先查询字典判断文件是否已经解析过，`false`则解析，`true`则跳过。

实际操作起来却遇到了一些意外情况，昨天就在处理意外中磕磕碰碰度过了。

#### 意外的uri

首先，在按照我的想法修改了程序之后，问题1在表面上被修复了，跳转到定义100%成功，即使符号定义在别的文件，多次跳转也不需要重新打开文件。
但是我debug发现，在指定路径下所有lua文件打开的情况下，全局文件解析字典中的条目个数经常大于lua文件总数。后来发现这是因为：对于同样的文件，在`onDidChangeContent()`接收到的uri可能会不一样。导致这个问题的因素目前发现有：
- 文件路径中紧接盘符后的冒号肯定会被转义为`%3A`，而其他的反斜杠有时会转义为`%5C`。为了网络传输数据不引起歧义，对某些字符转义我是表示理解的。可是为什么反斜杠有时候却不会被转义，我暂时还不清楚；
- 在`parse2()`中对`require`的文件名的处理是绝对不转义的，即冒号斜杠等的保持原样；
- `luapath`中指定的路径中的盘符可能是大写的，但`onDidChangeContent()`接收到的`uri`的盘符却是小写的，而**字典的`key`是大小写敏感的**。

各种不统一，导致同样文件的uri会不一样，所以全局文件解析字典里的条目就会大于总lua文件数了。对于这个问题，我的处理是提供一个函数对uri进行规范化处理，这些处理包括：
- 对给来的`uri`用`decodeURIComponent()`处理，得到转义前的路径；
- 将盘符统一转为小写，如`D:\`变成`d:\`；
- 将所有反斜杠转成斜杠，即`\`变成`/`。

#### 重复的符号

uri不一致问题解决了，部分跳转到定义也没问题了，但是有些符号的跳转会出现多个同样的选项，而在`Ctrl+Atl+O`调出跳转到符号功能时，也看到了多个同样的选项。debug发现，全局`luaSymbols`和`symbollist`列表中都存放着多个同样的条目，而且重复条目的数量会随着文件的关闭和打开次数递增。后来发现这是如下因素导致的：
- 在`onDidChangeContent()`中对一系列全局符号表的重置操作被去掉了；
- 在`onDidChangeContent()`每次触发时，都会调用`parse2()`来对改变的文件进行解析，而在`parse2()`中又会对一系列全局符号表进行**不查重的插入操作**。


#### 新的想法

要想解决重复插入问题，但又不能重置全局表，那么我想只有改变符号的存储策略了：**将符号分文件存储**。我的做法是这样的：
- 抽象出lua文件的概念，定义如下数据结构：

```
class LuaFile {
    uri:string;
    dependency:string[];
    calls:any[];
    symbolslist:any[];
    luaSymbols:any[];
}
```

`uri`是lua文件经过规范化处理的uri；`dependency`是当前文件与其他文件的依赖关系，保存的是一系列其他lua文件的规范化过的uri；`calls`、`symbolslist`、`luaSymbols`分别对应原来全局的`calls`、`symbolslist`、`luaSymbols`。
- 将前面提到的全局文件解析字典改为以uri为key，以`LuaFile`为value。
- 在`onDidChangeContent()`触发时，根据`uri`到全局文件解析字典里获取`LuaFile`，若空则创建。然后统一重置该`LuaFile`中除`uri`的数据，之后再解析文件。
- 将`parse2()`中解析依赖lua的逻辑抽取出来放到`parseDenpendency()`函数，该函数逻辑为：根据依赖文件的`uri`到全局文件解析字典获取`LuaFile`，若存在则跳过解析，若不存在则解析。然后还要将依赖文件的`uri`记录到父文件的`dependency`中去，这里要进行查重插入，**从全局角度看时间复杂度为`O(n^2)`**，考虑到依赖文件一般不会太多，所以将计就计。
- 将`onDefinition()`中的`calls`替换成根据`uri`获得的`LuaFile`中的`calls`，`luaSymbols`怎么办呢？那就从当前`LuaFile`开始，**递归遍历`dependency`来获得所有相关文件中的`luaSymbols`**。

这样一来，在程序刚启动时，打开第一个文件会将当前文件和所有依赖文件中的符号都解释出来，而以后再修改每个文件时，就只需要重新解释对应单个文件的符号，而不影响其他文件了。文件之间的依赖关系也能做到实时更新。经过实现亲测，跳转到符号定义暂时没发现问题了。

## 顺带解决的问题

#### 任性的require

在解决问题1的过程中，也顺便解决了问题3，即“`require`传入的字符串必须带有lua后缀才能到对应的lua文件搜索符号，然而正常的lua语法在`require`其他文件时是不需要lua后缀的”，解决方案是：
- 在`parse2()`中的`"CallExpression"`分支里，检查`tb.base.name`是否等于`"require"`，若是，则在路径名后要拼接`".lua"`；
- 考虑到`require`是基于模块的概念来工作的，**lua解释器会将路径中的点号变成斜杠**，所以我在给路径拼接`".lua"`之前，将所有出现的点号都换成了斜杠。

#### 自动补全的错觉

在解决问题1的过程中也顺便解决了问题2，即“若光标后面已有字符存在，则无法触发自动补全功能”。对于问题2的描述是我之前的**错觉**，之前看到的自动完成列表根本不是由server发过来的，而是client自己提供的（因为debug发现server发过来的东西与显示的不一致），而有时候又没有自动完成列表，是因为client自己也没辙了。造成无法正确显示server发过来列表的原因是：`onCompletion()`返回的列表类型`any[]`与协议要求的`CompletionItem[]`不一致，即使`luaSymbols`里面保存的条目含有`label`这个访问器。解决方案很简单，新建列表，把`luaSymbols`中的`label`数据加入到新结构的`label`属性中就行了。

## 发现新bug

另外我还发现一个新的bug，就是`Ctrl+Atl+O`调出的查找符号功能**官方约定是只查找当前文档的**，而不是跨文件的，而之前的代码实现是在`onDocumentSymbol()`触发时将所有所有文件的符号都返回了，所以在`Ctrl+Atl+O`输入其他文件符号时，定位是有了，但是却没有切换到正确的文件，从而表现出光标置于当前文件中的“别的文件的正确位置”上。解决方案很简单，既然已经实现份文件存储符号了，那么根据`uri`找到对应文件中的符号返回就行了。

## 后言

对于问题6，即变量符号跳转问题，可以说我目前才开始思考，因为我不去搞好前面的那些问题，我无法对问题6展开思考。况且，解决问题123也有助于我对整个插件的理解以及对于你代码思路的理解。











